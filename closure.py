# Copyright (c) Marco Giusti
# See LICENSE.txt for details.

import sys
import types
import re
import urllib
import urllib2
from twisted.python import usage


__version__ = '0.1'
__author__ = 'Marco Giusti <marco.giusti@gmail.com>'

CLOSUREURL = 'http://closure-compiler.appspot.com/compile'

SYNONYMS = {
	'jscode': 'js_code',
	'codeurl': 'code_url',
	'level': 'compilation_level',
	'format': 'output_format',
	'info': 'output_info',
	'externs': 'js_externs',
	'externurl': 'externs_url',
	'nodefault': 'exclude_default_externs',
	'filename': 'output_file_name',
	'closure': 'use_closure_library',
	'warning': 'warning_level'}

class CoerceParameter(usage.CoerceParameter):
	def dispatch(self, parameterName, value):
		if value is None:
			raise UsageError("Parameter '%s' requires an argument."
			% (parameterName,))
		try:
			value = self.coerce(value)
		except ValueError, e:
			raise UsageError("Parameter type enforcement failed: %s" % (e,))

		param = self.options.opts.get(parameterName, None)
		if not param:
			param = []
			self.options.opts[parameterName] = param
		param.append(value)

usage.CoerceParameter = CoerceParameter

LEVELS = {
	'whitespace': 'WHITESPACE_ONLY',
	'simple': 'SIMPLE_OPTIMIZATIONS',
	'advanced': 'ADVANCED_OPTIMIZATIONS'}

def levelCoerce(val):
	if val not in LEVELS:
		raise ValueError('Invalid level')
	return LEVELS[val]

levelCoerce.coerceDoc = 'One of: whitespace, simple or advanced'

FORMATS = ('xml', 'json', 'text')

def formatCoerce(val):
	if val not in FORMATS:
		raise ValueError('Invalid format')
	return val

formatCoerce.coerceDoc = 'One of: xml, json or text'

INFOS = ('compiled_code', 'warnings', 'errors', 'statistics')

def infoCoerce(val):
	if val not in INFOS:
		raise ValueError('Invalid info')
	return val

infoCoerce.coerceDoc = 'One of: compiled_code, warnings, errors or statistics'

class Options(usage.Options):
	optFlags = (
	('nodefault', '', 'Do NOT use common externs.'),
	('closure', 'c', 'The compiler looks for goog.require() '\
					 'statements in the source code and supplies the Closure '\
					 'Library code requested by any such statements.'),
	)

	optParameters = (
	('jscode', 'j', None, 'A string containing JavaScript.'),
	('codeurl', 'u', None, 'The URL of a JavaScript file. You can '
						   'specify this parameter multiple times to specify multiple'
						   ' input files.'),
	('level', 'l', None, 'The degree of '
						 'compression and optimization to apply to your '
						 'JavaScript.', levelCoerce),
	('format', 'f', None, 'The format for the Closure Compiler '
						  'service\'s output.', formatCoerce),
	('info', 'i', None, 'Indicates the kind of output you want from '
						'the compiler.'),
	('externs', 'x', None,
	 "The value of this parameter must be JavaScript code that declares function names or other symbols."),
	('externurl', 'e', None, 'The value of this parameter must be the'
							 ' URL of a file containing JavaScript that declares '
							 'function names or other symbols. You can specify this '
							 'parameter multiple times if you have multiple externs '
							 'files.'),
	('filename', 'n', None, 'If present, the Closure Compiler service '
							'caches the compiled code for one hour and makes it '
							'available through a special URL.'),
	('formatting', '', None, 'If present, this parameter must have a'
							 ' value of pretty_print or print_input_delimiter. You '
							 'can provide multiple formatting parameters in the same '
							 'request.'),
	('warning', 'w', None, 'Indicates the amount of information'
						   ' you want from the compiler about possible problems in '
						   'your code.'),
	)

	def opt_quiet(self):
		"""Outputs only syntax error messages and warnings generated by the
		optimization passes included in the compilation_level for the current
		compiler run."""
		self['warning'] = 'QUIET'

	opt_q = opt_quiet

	def opt_verbose(self):
		"""In addition to syntax errors and warnings generated by optimization
		passes, outputs warnings generated by all code-checking passes."""
		self['warnings'] = 'VERBOSE'

	opt_v = opt_verbose

	#noinspection PyMethodOverriding
	def parseArgs(self, filename = None):
		print 'Compling code..'
#		if filename is not None:
#			try:
#				self['jscode'] = open(filename).read()
#			except IOError, e:
#				raise usage.UsageError(e)

	def postOptions(self):
		if self.get('jscode') is None and self.get('codeurl') is None:
			raise usage.UsageError, 'You must specify at least one of '\
									'--jscode or --codeurl parameters.'

		if self.get('info') is None:
			self['info'] = ['compiled_code']


def compile(config):
#	try:
#		config.parseOptions(argv)
#	except usage.UsageError, e:
#		print '%s: %s' % (sys.argv[0], e)
#		print 'Use `%s --help\' for usage details.' % (sys.argv[0])
#		sys.exit(1)

	params = []
	for key, value in config.iteritems():
		if key in SYNONYMS:
			key = SYNONYMS[key]
		if type(value) is types.ListType:
			params.extend((key, v) for v in value)
		elif value is not None:
			params.append((key, value))

	up = urllib2.urlopen(CLOSUREURL, urllib.urlencode(params))
	buf = up.read()
	if buf.startswith('Error'):
		mo = re.search(r'^Error\((?P<code>\d+)\): (?P<msg>.+)$', buf)
		print >> sys.stderr, mo.group('msg')
		sys.exit(int(mo.group('code')))
	return buf

